/*******************************************************************************
 * Copyright (C) 2017 Ben Skinner
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.\
 *******************************************************************************/


package com.bmskinner.nuclear_morphology.gui.tabs;

import java.awt.Component;
import java.awt.Container;
import java.awt.Cursor;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.swing.JPanel;
import javax.swing.JTable;
import javax.swing.SwingWorker;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableModel;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.jfree.chart.JFreeChart;

import com.bmskinner.nuclear_morphology.charting.Cache;
import com.bmskinner.nuclear_morphology.charting.ChartCache;
import com.bmskinner.nuclear_morphology.charting.TableCache;
import com.bmskinner.nuclear_morphology.charting.charts.AbstractChartFactory;
import com.bmskinner.nuclear_morphology.charting.charts.ScatterChartFactory;
import com.bmskinner.nuclear_morphology.charting.charts.panels.ExportableChartPanel;
import com.bmskinner.nuclear_morphology.charting.datasets.AnalysisDatasetTableCreator;
import com.bmskinner.nuclear_morphology.charting.options.ChartOptions;
import com.bmskinner.nuclear_morphology.charting.options.TableOptions;
import com.bmskinner.nuclear_morphology.components.IAnalysisDataset;
import com.bmskinner.nuclear_morphology.core.DatasetListManager;
import com.bmskinner.nuclear_morphology.core.InputSupplier;
import com.bmskinner.nuclear_morphology.core.ThreadManager;
import com.bmskinner.nuclear_morphology.gui.CancellableRunnable;
import com.bmskinner.nuclear_morphology.gui.CellUpdatedEventListener;
import com.bmskinner.nuclear_morphology.gui.ChartOptionsRenderedEvent;
import com.bmskinner.nuclear_morphology.gui.ChartOptionsRenderedEventListener;
import com.bmskinner.nuclear_morphology.gui.DatasetEvent;
import com.bmskinner.nuclear_morphology.gui.DatasetEventHandler;
import com.bmskinner.nuclear_morphology.gui.DatasetUpdateEvent;
import com.bmskinner.nuclear_morphology.gui.DatasetUpdateEventHandler;
import com.bmskinner.nuclear_morphology.gui.EventListener;
import com.bmskinner.nuclear_morphology.gui.InterfaceEvent;
import com.bmskinner.nuclear_morphology.gui.InterfaceEventHandler;
import com.bmskinner.nuclear_morphology.gui.SignalChangeEvent;
import com.bmskinner.nuclear_morphology.gui.SignalChangeEventHandler;
import com.bmskinner.nuclear_morphology.gui.CellUpdatedEventListener.CellUpdatedEvent;
import com.bmskinner.nuclear_morphology.logging.Loggable;

/**
 * The DetailPanels hold chart and table caches, and track other DetailPanels
 * beneath them. Any dataset, interface or signal events generated by a
 * sub-panel are passed upwards to the parent detail panel.
 * 
 * @author bms41
 *
 */
@SuppressWarnings("serial")
public abstract class DetailPanel extends JPanel implements TabPanel, Loggable, CellUpdatedEventListener {

    private final List<Object> listeners          = new CopyOnWriteArrayList<Object>();
    
    private final InputSupplier inputSupplier;

    private final TabPanel parentPanel;
    private final List<TabPanel> subPanels = new ArrayList<TabPanel>();

    // The chart cache holds rendered charts for all selected options, until a
    // change is made to a dataset
    // The table cache does the same for table models
    protected final Cache chartCache = new ChartCache();
    protected final Cache tableCache = new TableCache();
    
    private static final String DEFAULT_TAB_TITLE = "Default";
    private final String panelTabTitleLbl;

    volatile private AtomicBoolean isUpdating = new AtomicBoolean(false);
    
    private final DatasetEventHandler       dh  = new DatasetEventHandler(this);
    private final InterfaceEventHandler     ih  = new InterfaceEventHandler(this);
    private final DatasetUpdateEventHandler duh = new DatasetUpdateEventHandler(this);
    private final SignalChangeEventHandler  sh  = new SignalChangeEventHandler(this);
    
    private boolean isCellUpdateMade = false; // for editing panels to batch UI update requests

    public DetailPanel(@NonNull InputSupplier context) {
        this(context, DEFAULT_TAB_TITLE);
    }
    
    public DetailPanel(@NonNull TabPanel parent) {
    	this(parent.getInputSupplier(), parent, DEFAULT_TAB_TITLE);
    }
    
    public DetailPanel(@NonNull InputSupplier context, String title) {
        this(context, null, title);        
    }
    
    public DetailPanel(@NonNull InputSupplier context, @Nullable TabPanel parent, @NonNull String title) {
    	inputSupplier = context;
        parentPanel = parent;
//        this.addChartOptionsRenderedEventListener(this);
        panelTabTitleLbl = title;
    }
    
    /**
     * Get the preferred name of the panel for use in tabs
     * @return the title
     */
    public String getPanelTitle(){
        return panelTabTitleLbl;
    }
    
    @Override
    public InputSupplier getInputSupplier() {
    	return inputSupplier;
    }

    /**
     * Add another detail panel as a sub panel to this. This will pass on
     * refreshes and UI updates
     * 
     * @param panel the panel to add
     */
    @Override
	public void addSubPanel(final TabPanel panel) {
        subPanels.add(panel);
        panel.addSignalChangeListener(this);
        panel.addDatasetEventListener(this);
        panel.addInterfaceEventListener(this);

        // This will signal to sub panels to update
        this.addDatasetUpdateEventListener(panel);
    }

    @Override
    public List<TabPanel> getSubPanels() {
        return subPanels;
    }

    @Override
    public boolean hasSubPanels() {
        return subPanels.size() > 0;
    }
    
    @Override
    public TabPanel getParentPanel(){
    	return parentPanel;
    }

    /**
     * Fetch the currently active dataset for the panel. Use when only one
     * dataset is expected to be visible; this simply accesses the first dataset
     * in the list provided
     * 
     * @return
     */
    @Override
	public synchronized IAnalysisDataset activeDataset() {
        return DatasetListManager.getInstance().getActiveDataset();
    }


    /**
     * Test if only a single dataset is selected
     * 
     * @return
     */
    public synchronized boolean isSingleDataset() {
        // return(this.list.size()==1);
        return DatasetListManager.getInstance().isSingleDataset();
    }

    /**
     * Test if multiple datasets are selected
     * 
     * @return
     */
    public synchronized boolean isMultipleDatasets() {
        return DatasetListManager.getInstance().isMultipleDatasets();
    }

    public synchronized boolean hasDatasets() {
        return DatasetListManager.getInstance().hasSelectedDatasets();
    }

    /**
     * Get the datasets currently displayed in this panel
     * @return a list of datasets
     */
    protected synchronized List<IAnalysisDataset> getDatasets() {
        return DatasetListManager.getInstance().getSelectedDatasets();
    }

    /**
     * Get the chart cache for the panel
     * @return
     */
    public synchronized Cache getChartCache() {
        return this.chartCache;
    }

    @Override
	public synchronized boolean isUpdating() {

        if (this.isUpdating.get()) {
            return true;
        }

        for (TabPanel panel : this.subPanels) {
            if (panel.isUpdating()) {
                return true;
            }
        }

        return false;
    }

    protected synchronized void setUpdating(boolean b) {
        this.isUpdating.set(b);
    }

    /**
     * Toggle wait cursor on element
     * 
     * @param b
     */
    @Override
	public synchronized void setAnalysing(boolean b) {
        if (b) {

            for (Component c : this.getComponents()) {
                c.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
            }

            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

        } else {

            for (Component c : this.getComponents()) {
                c.setCursor(Cursor.getDefaultCursor());
            }
            this.setCursor(Cursor.getDefaultCursor());
        }
        for (TabPanel panel : this.subPanels) {
            panel.setAnalysing(b);
        }
    }


    /**
     * Force any chart panels currently visible on screen to redraw, allowing
     * text to be rendered with the appropriate aspect ratio
     */
    @Override
	public synchronized void updateSize() {

        updateSize(this);

        for (TabPanel panel : this.subPanels) {
            panel.updateSize();
        }
    }

    /**
     * Carries out the resize - recursively search all containers for chart
     * panels, and refresh the chart cache if any are found.
     * 
     * @param container
     */
    private synchronized void updateSize(Container container) {
        for (Component c : container.getComponents()) {
            if (c instanceof ExportableChartPanel) {

                if (c.isShowing()) {
                    this.refreshChartCache();
                    return;
                }

            }

            if (c instanceof Container) {
                updateSize((Container) c);
            }

        }
    }

    @Override
    public synchronized void update() {
    	
        setUpdating(true);

        for (TabPanel t : this.getSubPanels()) {
            t.update();
        }
        List<IAnalysisDataset> list = DatasetListManager.getInstance().getSelectedDatasets();
        updateDetail(list);

    }
    
    /**
     * Update with the given dataset. 
     * @param d
     */
    protected synchronized void update(final IAnalysisDataset d) {
        List<IAnalysisDataset> list = new ArrayList<IAnalysisDataset>();
        list.add(d);
        update(list);
    }

    @Override
    public synchronized void update(final List<IAnalysisDataset> list) {

        setUpdating(true);

        for (TabPanel t : this.getSubPanels()) {
            t.update(list);
        }

        updateDetail(list);

    }

    /**
     * This method sets which of the overriden handling methods are run by
     * extending classes.
     */
    private synchronized void updateDetail(List<IAnalysisDataset> list) {
//        List<IAnalysisDataset> list = DatasetListManager.getInstance().getSelectedDatasets();

        try {
            if (list.isEmpty()) {
                updateNull();
                return;
            }

            if (list.size() > 1) {
                updateMultiple();
                return;
            }

            updateSingle();

        } catch (Exception e) {
            warn("Error updating panel " + this.getClass().getName());
            e.printStackTrace();
            fine("Error updating panel", e); // save detail for fine logging

            try {
                updateNull();
            } catch (Exception e1) {
                warn(this.getClass().getName() + ": Error recovering from error updating panel");
                fine("Error recovering from error updating panel", e1);
                setUpdating(false);
            }
        } finally {
            setUpdating(false);
        }
    }

    /**
     * This method must be overridden by the extending class to perform the
     * actual update when a single dataset is selected
     */
    protected synchronized void updateSingle() {
//        finest(this.getClass().getName() + ": Updating single dataset");
    }

    /**
     * This method must be overridden by the extending class to perform the
     * actual update when multiple datasets are selected
     */
    protected synchronized void updateMultiple() {
//        finest(this.getClass().getName() + ": Updating multiple datasets");
    }

    /**
     * This method must be overridden by the extending class to perform the
     * actual update when no datasets are selected
     */
    protected synchronized void updateNull() {
//        finest(this.getClass().getName() + ": Updating null dataset");
    }

    /**
     * Fetch the chart with the given options from the cache, and display it in
     * the target ChartPanel. If the chart is not in the cache, a SwingWorker
     * will be created to render the chart and display it once complete. Note
     * that this requires the options to have been created with a setTarget()
     * value.
     * 
     * @param options
     */
    protected synchronized void setChart(@NonNull ChartOptions options) {
        if (chartCache.has(options)) {
            JFreeChart chart = chartCache.get(options);
            if (options.getTarget() != null)
                options.getTarget().setChart(chart);

        } else { // No cached chart
            // Make a background worker to generate the chart and
            // update the target chart panel when done
            ChartFactoryWorker worker = new ChartFactoryWorker(options);
            ThreadManager.getInstance().submit(worker);
        }
    }

    /**
     * Fetch the table model with the given options from the cache, and display
     * it in the target JTable. If the model is not in the cache, a SwingWorker
     * will be created to render the model and display it once complete. Note
     * that this requires the options to have been created with a setTarget()
     * value.
     * 
     * @param options
     */
    protected synchronized void setTable(TableOptions options) {
        if (chartCache.has(options)) {
            TableModel model = getTableCache().get(options);

            if (options.getTarget() != null) {
                options.getTarget().setModel(model);
            }

        } else { // No cached chart

            // Make a background worker to generate the chart and
            // update the target chart panel when done
            TableFactoryWorker worker = new TableFactoryWorker(options);

            ThreadManager.getInstance().submit(worker);// worker.execute();
        }
    }

    /**
     * Fetch the desired chart, either from the cache, or by creating it
     * 
     * @param options
     * @return
     * @throws Exception
     */
    protected synchronized JFreeChart getChart(@NonNull ChartOptions options) {

        if (chartCache.has(options)) {
            return chartCache.get(options);
        } else { // No cached chart

            try {
                JFreeChart chart = createPanelChartType(options);
                chartCache.add(options, chart);
                return chart;
            } catch (Exception e) {
                warn("Error creating chart: " + this.getClass().getSimpleName());
                fine(this.getClass().getName() + ": Error creating chart", e);
                return ScatterChartFactory.makeErrorChart();
            }
        }
    }

    /**
     * Fetch the desired table, either from the cache, or by creating it
     * 
     * @param options
     * @return
     * @throws Exception
     */
    protected synchronized TableModel getTable(TableOptions options) {

        TableModel model;
        if (getTableCache().has(options)) {
//            finest("Fetched cached table");
            model = getTableCache().get(options);
        } else {
            try {
                model = createPanelTableType(options);
            } catch (Exception e) {
                warn("Error creating table: " + this.getClass().getSimpleName());
                fine(this.getClass().getName() + ": Error creating table", e);
                model = AnalysisDatasetTableCreator.createBlankTable();
            }
//            finest("Added cached table");
            getTableCache().add(options, model);
        }
        return model;
    }

    /**
     * This should be overridden to create the appropriate tables for caching
     * 
     * @param options
     *            the table options
     * @return null unless overridden
     * @throws Exception
     */
    protected TableModel createPanelTableType(@NonNull TableOptions options) {
        return null;
    }

    /**
     * This should be overridden to create the appropriate charts for caching
     * 
     * @param options
     *            the chart options
     * @return null unless overridden
     * @throws Exception
     */
    protected JFreeChart createPanelChartType(@NonNull ChartOptions options) {
        return null;
    }

    /**
     * Remove all charts from the cache. Does not invoke an update
     * 
     * @param list
     */
    @Override
	public synchronized void clearChartCache() {
        this.getChartCache().clear();
        for (TabPanel panel : this.subPanels) {
            panel.clearChartCache();
        }
//        finest("Chart cache cleared");
    }

    /**
     * Remove all charts from the cache. Does not invoke an update
     * 
     * @param list
     */
    @Override
	public synchronized void clearChartCache(final List<IAnalysisDataset> list) {
        getChartCache().clear(list);
        if (hasSubPanels()) {
            for (TabPanel panel : this.subPanels) {
                panel.clearChartCache(list);
            }
        }
    }

    /**
     * Remove all charts from the cache. Then call an update of the panel
     * 
     * @param list
     */
    @Override
	public synchronized void refreshChartCache() {
        clearChartCache();
        update(getDatasets());
    }

    /**
     * Remove all charts from the cache containing datasets in the given list,
     * so they will be recalculated. This allows a refresh of some of the charts
     * in the chache, without recalculating everything
     * 
     * @param list
     */
    @Override
	public synchronized void refreshChartCache(final List<IAnalysisDataset> list) {
        clearChartCache(list);
        update(getDatasets());
    }

    public synchronized Cache getTableCache() {
        return this.tableCache;
    }

    /**
     * Remove all tables from the cache
     * 
     * @param list
     */
    @Override
	public synchronized void clearTableCache() {
        getTableCache().clear();
        for (TabPanel panel : this.subPanels) {
            panel.clearTableCache();
        }
    }

    /**
     * Remove all tables from the cache containing datasets in the given list,
     * so they will be recalculated
     * 
     * @param list
     */
    @Override
	public synchronized void clearTableCache(final List<IAnalysisDataset> list) {
        getTableCache().clear(list);
        if (this.hasSubPanels()) {
            for (TabPanel panel : this.subPanels) {
                panel.clearTableCache(list);
            }
        }
    }

    /**
     * Remove all charts from the cache and trigger an update
     * 
     * @param list
     */
    @Override
	public synchronized void refreshTableCache() {
        clearTableCache();
        update(getDatasets());
    }

    /**
     * Remove all tables from the cache containing datasets in the given list,
     * so they will be recalculated
     * 
     * @param list
     */
    @Override
	public synchronized void refreshTableCache(final List<IAnalysisDataset> list) {
        clearTableCache(list);
        this.update(getDatasets());
    }
    
    /**
     * Set the given table to use a custom table renderer. The renderer will be
     * used for every column except the first.
     * 
     * @param table
     */
    protected synchronized void setRenderer(@NonNull JTable table, @NonNull TableCellRenderer renderer) {
        int columns = table.getColumnModel().getColumnCount();
        if (columns > 1) {
            for (int i = 1; i < columns; i++) {
                table.getColumnModel().getColumn(i).setCellRenderer(renderer);
            }
        }
    }

    @Override
	public synchronized void addSignalChangeListener(EventListener l) {
        sh.addListener(l);
    }

    @Override
	public synchronized void removeSignalChangeListener(EventListener l) {
        sh.removeListener(l);
    }
    
    @Override
	public synchronized void addDatasetEventListener(EventListener l) {
        dh.addListener(l);
    }

    @Override
	public synchronized void removeDatasetEventListener(EventListener l) {
        dh.removeListener(l);
    }
    
    @Override
	public synchronized void addDatasetUpdateEventListener(EventListener l) {
        duh.addListener(l);
    }

    @Override
	public synchronized void removeDatasetUpdateEventListener(EventListener l) {
        duh.removeListener(l);
    }

    @Override
	public synchronized void addInterfaceEventListener(EventListener l) {
        ih.addListener(l);
    }

    @Override
	public synchronized void removeInterfaceEventListener(EventListener l) {
        ih.removeListener(l);
    }

    @Override
    public DatasetEventHandler getDatasetEventHandler(){
        return dh;
    }
    
    @Override
    public InterfaceEventHandler getInterfaceEventHandler(){
        return ih;
    }
    
    @Override
    public DatasetUpdateEventHandler getDatasetUpdateEventHandler(){
        return duh;
    }
    
    @Override
    public SignalChangeEventHandler getSignalChangeEventHandler(){
        return sh;
    }

    @Override
    public void eventReceived(InterfaceEvent event) {
        // Pass messages upwards
        for (TabPanel panel : this.subPanels) {
            if (event.getSource().equals(panel)) {
                ih.fire(new InterfaceEvent(this, event));
            }
        }
    }
    
    @Override
    public void eventReceived(DatasetEvent event) {
        // Pass messages upwards
        for (TabPanel panel : this.subPanels) {
            if (event.getSource().equals(panel)) {
                dh.fireDatasetEvent(new DatasetEvent(this, event));
            }
        }
    }

    @Override
    public void eventReceived(SignalChangeEvent event) {
        // Pass messages upwards
        for (TabPanel panel : this.subPanels) {
            if (event.getSource().equals(panel)) {
                sh.fire(new SignalChangeEvent(this, event));
            }
        }
    }
    
    @Override
    public void eventReceived(ChartOptionsRenderedEvent e) {
        // To be overridden as needed by extending classes
        update(getDatasets());
    }
    
    /**
     * Charting can be an intensive process, especially with background images
     * being imported for outline charts. This worker will keep the chart
     * generation off the EDT
     * 
     * @author bms41
     *
     */
    protected class ChartFactoryWorker extends SwingWorker<JFreeChart, Void> implements CancellableRunnable {

        final private ChartOptions options;

        public ChartFactoryWorker(final ChartOptions o) {
            options = o;
        }

        @Override
        protected synchronized JFreeChart doInBackground() throws Exception {

            try {
                if (options.hasTarget()) {
                    options.getTarget().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                    options.getTarget().setChart(AbstractChartFactory.createLoadingChart());
                }

                JFreeChart chart = createPanelChartType(options);
                chartCache.add(options, chart);

                return chart;
            } catch (Exception e) {
                warn("Error creating chart");
                stack("Error creating chart", e);
                return null;
            }

        }

        @Override
        public synchronized void done() {

            try {
                if (options.hasTarget()) {
                    options.getTarget().setChart(get());
                    options.getTarget().setCursor(Cursor.getDefaultCursor());
                }
            } catch (InterruptedException e) {
                warn("Interruption to charting in " + DetailPanel.this.getClass().getName());
                stack(e);
            } catch (ExecutionException e) {
                warn("Excecution error in charting in " + DetailPanel.this.getClass().getName());
                stack(e);
            }
        }

        @Override
        public void cancel() {
            this.cancel(true);
        }

    }

    /**
     * Tables can also be an intensive process, especially with venn
     * comparisons. This worker will keep the model generation off the EDT
     * 
     * @author bms41
     *
     */
    protected class TableFactoryWorker extends SwingWorker<TableModel, Void> implements CancellableRunnable {

        final private TableOptions options;

        public TableFactoryWorker(@NonNull final TableOptions o) {
            options = o;

        }

        @Override
        protected synchronized TableModel doInBackground() throws Exception {

            try {
                if (options.hasTarget())
                    options.getTarget().setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
                
                TableModel model = createPanelTableType(options);
                tableCache.add(options, model);

                return model;
            } catch (Exception e) {
                warn("Error creating table model");
                stack(e);
                return null;
            }

        }

        @Override
        public synchronized void done() {

            try {
                if (options.getTarget() != null) {
                    TableModel model = get();
                    if (model != null) {
                        options.getTarget().setModel(model);
                        setRenderers();
                    }

                    options.getTarget().setCursor(Cursor.getDefaultCursor());
                }
            } catch (InterruptedException e) {
                warn("Interruption to table creation in " + DetailPanel.this.getClass().getName());
                stack("Error in table worker", e);
            } catch (ExecutionException e) {
                warn("Excecution error in table creation in " + DetailPanel.this.getClass().getName());
                stack("Error in table worker", e);
            }
        }

        @Override
        public void cancel() {
            log("Cancelling detail panel table update");
            this.cancel(true);
        }
        
        
        private synchronized void setRenderers() {
            JTable table = options.getTarget();
            
           if(table.getRowCount()==0)
        	   return;
           
            int columns = table.getColumnModel().getColumnCount();

            for (int i : options.getRendererColumns()) {

                TableCellRenderer renderer = options.getRenderer(i);

                if (i == TableOptions.FIRST_COLUMN) {

                    table.getColumnModel().getColumn(0).setCellRenderer(renderer);
                    continue;
                }

                if (i == TableOptions.ALL_COLUMNS) {
                    for (int j = 0; j < columns; j++) {
                        table.getColumnModel().getColumn(j).setCellRenderer(renderer);
                    }
                    continue;
                }

                if (i == TableOptions.ALL_EXCEPT_FIRST_COLUMN) {
                    for (int j = 1; j < columns; j++) {
                        table.getColumnModel().getColumn(j).setCellRenderer(renderer);
                    }
                    continue;
                }

                table.getColumnModel().getColumn(i).setCellRenderer(renderer);

            }

        }

    }

    /**
     * Signal listeners that the chart with the given options has been rendered
     * 
     * @param options
     */
    public void fireChartOptionsRenderedEvent(ChartOptions options) {
        ChartOptionsRenderedEvent e = new ChartOptionsRenderedEvent(this, options);
        Iterator<Object> iterator = listeners.iterator();
        while (iterator.hasNext()) {
            ((ChartOptionsRenderedEventListener) iterator.next()).chartOptionsRenderedEventReceived(e);
        }
    }

    /**
     * Add a listener for completed charts rendered into the chart cache of this
     * panel.
     * 
     * @param l
     */
    public synchronized void addChartOptionsRenderedEventListener(ChartOptionsRenderedEventListener l) {
        listeners.add(l);
    }

    public synchronized void removeChartOptionsRenderedEventListener(ChartOptionsRenderedEventListener l) {
        listeners.remove(l);
    }

    /*
     * (non-Javadoc)
     * 
     * @see gui.tabs.TabPanel#setChartsAndTablesLoading() This sets all sub
     * panels to invoke the loading state. Any implementing class must still
     * override this method to provide the expected behaviour for the panel and
     * call super.setChartsAndTablesLoading()
     */
    @Override
    public synchronized void setChartsAndTablesLoading() {
        for (TabPanel p : subPanels) {
            p.setChartsAndTablesLoading();
        }
    }

    @Override
    public void eventReceived(DatasetUpdateEvent e) {
        // Signal sub panels to update
        duh.fireDatasetUpdateEvent(e.getDatasets());
        this.update(e.getDatasets());
    }
    

	@Override
	public void cellUpdatedEventReceived(CellUpdatedEvent event) {
		isCellUpdateMade = true;
	}
	
	@Override
	public boolean hasCellUpdate() {
		boolean result = isCellUpdateMade;
		for(TabPanel t : getSubPanels()) {
			result |= t.hasCellUpdate();
		}
		return result;
	}

	@Override
	public void setCellUpdate(boolean b) {
		isCellUpdateMade = b;
		for(TabPanel t : getSubPanels()) {
			t.setCellUpdate(b);
		}
		
	}

}
