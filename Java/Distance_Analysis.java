/*
-------------------------------------------------
SUBTELOMERIC PROBE ANALYSIS: IMAGEJ PLUGIN
-------------------------------------------------
Copyright (C) Ben Skinner 2015



  ---------------
  PLOT AND IMAGE FILES
  ---------------

  ---------------
  LOG FILES
  ---------------
  

*/
import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.gui.Overlay;
import ij.gui.PolygonRoi;
import ij.gui.Roi;
import ij.gui.Plot;
import ij.gui.PlotWindow;
import ij.gui.ProgressBar;
import ij.gui.TextRoi;
import ij.io.FileInfo;
import ij.io.FileOpener;
import ij.io.DirectoryChooser;
import ij.io.Opener;
import ij.io.OpenDialog;
import ij.io.RandomAccessStream;
import ij.measure.ResultsTable;
import ij.measure.SplineFitter;
import ij.plugin.ChannelSplitter;
import ij.plugin.PlugIn;
import ij.plugin.filter.Analyzer;
import ij.plugin.filter.ParticleAnalyzer;
import ij.plugin.frame.RoiManager;
import ij.process.FloatPolygon;
import ij.process.FloatProcessor;
import ij.process.ImageConverter;
import ij.process.ImageProcessor;
import ij.process.StackConverter;
import java.awt.BasicStroke;
import java.awt.Shape;
import java.awt.Color;
import java.awt.geom.*;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.Polygon;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.util.*;
import nucleusAnalysis.*;

public class Distance_Analysis
  extends ImagePlus
  implements PlugIn
{

  // colour channels
  private static final int RED_CHANNEL   = 0;
  private static final int GREEN_CHANNEL = 1;
  private static final int BLUE_CHANNEL  = 2;

  private static final String[] fileTypes = {".tif", ".tiff", ".jpg"};

  // Values for deciding whether an object is a signal
  private static final int    SIGNAL_THRESHOLD = 70;
  private static final double MIN_SIGNAL_SIZE  = 5; // how small can a signal be
  private static final double MAX_SIGNAL_SIZE  = 50; // how large can a signal be
  
  // private static final double ANGLE_THRESHOLD = 40.0; // when calculating local minima, ignore angles above this

  /* VALUES FOR DECIDING IF AN OBJECT IS A NUCLEUS */
  private static final int NUCLEUS_THRESHOLD    = 40;
  private static final double MIN_NUCLEAR_SIZE  = 500;
  private static final double MAX_NUCLEAR_SIZE  = 10000;
  private static final double MIN_NUCLEAR_CIRC  = 0.3;
  private static final double MAX_NUCLEAR_CIRC  = 1;
  private static final double PROFILE_INCREMENT = 0.5;

  // failure codes - not in use, keep to add back to logFailed in refilter
  private static final int FAILURE_TIP       = 1;
  private static final int FAILURE_TAIL      = 2;
  private static final int FAILURE_THRESHOLD = 4;
  private static final int FAILURE_FERET     = 8;
  private static final int FAILURE_ARRAY     = 16;
  private static final int FAILURE_AREA      = 32;
  private static final int FAILURE_PERIM     = 64;
  private static final int FAILURE_OTHER     = 128;

  // counts of nuclei processed
  private int totalNuclei        = 0;
  private int nucleiFailedOnTip  = 0;
  private int nucleiFailedOnTail = 0;
  private int nucleiFailedOther  = 0; // generic reasons for failure

  // logging
  // private String logFile;
  // private String failedFile;
  // private String medianFile;
  // private String statsFile;
  // private String debugFile;

  private NucleusCollection completeCollection;
  private NucleusCollection failedNuclei;
    
  public void run(String paramString)  {

    DirectoryChooser localOpenDialog = new DirectoryChooser("Select directory of images...");
    String folderName = localOpenDialog.getDirectory();

    IJ.showStatus("Opening directory: " + folderName);
    IJ.log("Directory: "+folderName);

    File folder = new File(folderName);
    File[] listOfFiles = folder.listFiles();
 
    completeCollection = new NucleusCollection(folder, "complete");
    failedNuclei       = new NucleusCollection(folder, "failed");

    for (File file : listOfFiles) {
      if (file.isFile()) {

        String fileName = file.getName();

        for( String fileType : fileTypes){
          if( fileName.endsWith(fileType) ){
            IJ.log("File:    "+fileName);

            if(!fileName.startsWith("composite") && !fileName.startsWith("plot") ){ // skip files generated by the script itself in past iterations
	            try {

	              // open and process each image here
	              // String path = folderName+fileName;
                File path = new File(folderName+fileName);
	              Opener localOpener = new Opener();
	              ImagePlus localImagePlus = localOpener.openImage(path.getAbsolutePath());             
	              // handle the image
	              processImage(localImagePlus, path);
	              localImagePlus.close();

	            } catch (Exception e) { 
	                IJ.log("Error in image processing: "+e);
	            }
	          }
          }
        }
      }
    }

    IJ.log("Within folder:");
    IJ.log("Total nuclei  : "+this.totalNuclei);
    IJ.log("Failed on tip : "+this.nucleiFailedOnTip);
    IJ.log("Failed (other): "+this.nucleiFailedOther);
    int analysed = completeCollection.getNucleusCount();
    IJ.log("Before filtering: "+analysed);


    // Analyse nuclei and signals
    // collection only has nuclei with 1 of each signal

    // Calculate the distance between signals
    for(int i=0;i<completeCollection.getNucleusCount();i++){
      Nucleus n = completeCollection.getNucleus(i);
      n.exportSignalDistanceMatrix();
    }

    // export separate combined file for nuclei with only one signal per channel
    completeCollection.exportDistancesBetweenSingleSignals();

    IJ.log("Done");

    
  }

  /*
    Input: ImagePlus image, String path to the image
    Detects nuclei within the image
    For each nuclcus, performs the full analysis
    Adds stats for each nucleus analysed to the global stats arrays
    Calculates the normalised profile plots and stores in <finalResults>
    Draws the profile on the global chart
  */
  public void processImage(ImagePlus image, File path){

    RoiManager nucleiInImage;

    nucleiInImage = findNucleiInImage(image);

    Roi[] roiArray = nucleiInImage.getSelectedRoisAsArray();
    int i = 0;

    for(Roi roi : roiArray){
      
      IJ.log("  Analysing nucleus "+i);
      try{
      	analyseNucleus(roi, image, i, path); // get the profile data back for the nucleus
      	this.totalNuclei++;
      } catch(Exception e){
      	IJ.log("  Error analysing nucleus: "+e);
      }
      i++;
    } 
  }

  /*
    Within a given image, look for nuclei using the particle analyser.
    Return an RoiManager containing the outlines of all potential nuclei
  */
  public RoiManager findNucleiInImage(ImagePlus image){

    RoiManager manager = new RoiManager(true);

    // split out blue channel
    ChannelSplitter cs = new ChannelSplitter();
    ImagePlus[] channels = cs.split(image);
    ImagePlus blue = channels[BLUE_CHANNEL];
    
    // threshold
    ImageProcessor ip = blue.getChannelProcessor();
    ip.smooth();
    ip.threshold(NUCLEUS_THRESHOLD);
    ip.invert();
    // blue.show();

    // run the particle analyser
    ResultsTable rt = new ResultsTable();
    ParticleAnalyzer pa = new ParticleAnalyzer(ParticleAnalyzer.ADD_TO_MANAGER | ParticleAnalyzer.EXCLUDE_EDGE_PARTICLES, 
                ParticleAnalyzer.CENTER_OF_MASS | ParticleAnalyzer.AREA ,
                 rt, MIN_NUCLEAR_SIZE, MAX_NUCLEAR_SIZE, MIN_NUCLEAR_CIRC, MAX_NUCLEAR_CIRC);
    try {
      pa.setRoiManager(manager);
      boolean success = pa.analyze(blue);
      if(success){
        String plural = manager.getCount() == 1 ? "nucleus" : "nuclei";
        IJ.log("  Found "+manager.getCount()+ " "+plural);
      } else {
        IJ.log("  Unable to perform particle analysis");
      }
    } catch(Exception e){
       IJ.log("  Error in particle analyser: "+e);
    } finally {
      blue.close();
    }
   
   return manager;
  }

  /*
    Identify signals
    Add to collection
  */
  public void analyseNucleus(Roi nucleus, ImagePlus image, int nucleusNumber, File path){
    
    boolean nucleusPassedChecks = true; // any check can disable this
    int failureReason = 0;


    // make a copy of the nucleus only for saving out and processing
    image.setRoi(nucleus);
    image.copy();
    ImagePlus smallRegion = ImagePlus.getClipboard();

    nucleus.setLocation(0,0); // translate the roi to the new image coordinates
    smallRegion.setRoi(nucleus);


    // prepare an image processor to annotate the image
    ImageProcessor ip = smallRegion.getProcessor();


    // turn roi into Nucleus for manipulation
    Nucleus currentNucleus = new Nucleus(nucleus, path, smallRegion, nucleusNumber);

    // find the signals
    // within nuclear roi, analyze particles in colour channels
    RoiManager   redSignalManager = findSignalInNucleus(smallRegion, 0);
    RoiManager greenSignalManager = findSignalInNucleus(smallRegion, 1);

    Roi[] redSignals =     redSignalManager.getSelectedRoisAsArray();
    Roi[] greenSignals = greenSignalManager.getSelectedRoisAsArray();

    for(Roi roi : redSignals){

      ResultsTable redResults = findSignalMeasurements(smallRegion, roi, 1);
      XYPoint signalCoM = new XYPoint(redResults.getValue("XM", 0),  redResults.getValue("YM", 0) );
      currentNucleus.addRedSignal( new NuclearSignal( roi, 
                                                redResults.getValue("Area",0), 
                                                redResults.getValue("Feret",0), 
                                                redResults.getValue("Perim.",0), 
                                                signalCoM));
    }

    // Add green signals to the nucleus
    for(Roi roi : greenSignals){

      ResultsTable greenResults = findSignalMeasurements(smallRegion, roi, 1);
      XYPoint signalCoM = new XYPoint(greenResults.getValue("XM", 0),  greenResults.getValue("YM", 0) );
      currentNucleus.addGreenSignal( new NuclearSignal( roi, 
                                                  greenResults.getValue("Area",0), 
                                                  greenResults.getValue("Feret",0), 
                                                  greenResults.getValue("Perim.",0), 
                                                  signalCoM));
    }    

    // if everything checks out, add the measured parameters to the global pool
    if(nucleusPassedChecks){
      this.completeCollection.addNucleus(currentNucleus);
    } else {
      this.failedNuclei.addNucleus(currentNucleus);
    }
  }

  public RoiManager findSignalInNucleus(ImagePlus image, int channel){

    RoiManager manager = new RoiManager(true);
    ChannelSplitter cs = new ChannelSplitter();
    ImagePlus[] channels = cs.split(image);
    ImagePlus imp = channels[channel];
    String colour = channel == 0 ? "red" : "green";

    
    // threshold
    ImageProcessor ip = imp.getChannelProcessor();
    ip.threshold(SIGNAL_THRESHOLD);
    ip.invert();

    // run the particle analyser
    ResultsTable rt = new ResultsTable();
    ParticleAnalyzer pa = new ParticleAnalyzer( ParticleAnalyzer.ADD_TO_MANAGER, 
    										                        ParticleAnalyzer.CENTER_OF_MASS | ParticleAnalyzer.AREA,
                                                 rt, 
                                                 MIN_SIGNAL_SIZE, 
                                                 MAX_SIGNAL_SIZE);
    try {
      pa.setRoiManager(manager);
      boolean success = pa.analyze(imp);
      if(success){
        String signalPlural = manager.getCount() == 1 ? "signal" : "signals"; // I am pedantic
        IJ.log("    Found "+manager.getCount()+ " "+signalPlural+" in "+colour+" channel");

      } else {
        IJ.log("    Unable to perform signal analysis");
      }
    } catch(Exception e){
       IJ.log("    Error: "+e);
    } finally {
      imp.close();
    }
    return manager;
  }

  /*
    Use the particle analyser to detect the nucleus in an image.
    Calculate parameters of interest and return a ResultsTable.
  */
  public ResultsTable findSignalMeasurements(ImagePlus imp, Roi roi, int channel){

    ChannelSplitter cs = new ChannelSplitter();
    ImagePlus[] channels = cs.split(imp);
    ImagePlus signalChannel = channels[channel];

    signalChannel.setRoi(roi);
    double feretDiameter = roi.getFeretsDiameter();

    ResultsTable rt = new ResultsTable();

    Analyzer an = new Analyzer(signalChannel, Analyzer.CENTER_OF_MASS | Analyzer.PERIMETER | Analyzer.AREA | Analyzer.FERET, rt);
    an.measure();
    return rt;
  }

}
