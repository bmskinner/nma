// -------------------------------------------------
// ROI HANDLING FUNCTIONS
// -------------------------------------------------

function ROI_to_x(array){
	// convert an ROI selection to array of x coordinates
	length = array[0];
	
	x_selection = newArray();		
	for (i=1; i<=length; i++){
		x_selection = Array.concat(x_selection, array[i]);
	}
	return x_selection;
}

function ROI_to_y(array){
	// convert an ROI selection to array of y coordinates
	length = array[0];
	y_selection = newArray();		
	for (i=1; i<=length; i++){
		y_selection = Array.concat(y_selection, array[i+length]);
	}
	return y_selection;
}

function createROI(x, y){
	// transfer x and y arrays to ROI format
	// 0 - length of array
	// 1 - first x
	// [0]+1 - first y
	length = x.length;
	full_array =  Array.concat(x,y);
	full_array =  Array.concat(length,full_array);
	return full_array;
}

function shuffleROI(roi){
		
	// look for largest discontinuity between points
	x_points = ROI_to_x(roi);
	y_points = ROI_to_y(roi);
	
	last_x = x_points[x_points.length-1];
	last_y = y_points[y_points.length-1];
	
	max_distance = 0;
	max_i = 0;
	
	if(showDebug){
		print("Shuffling ROI:");
	}
	// find the two most divergent points
	for(i=0;i<x_points.length;i++){
	
		pointA = newArray(x_points[i],y_points[i]);
		
		if(i==x_points.length-1){ // check last against first
			pointB = newArray(x_points[0],y_points[0]);
			distance = getLength( pointA, pointB);
		} else { // otherwise check to the next in array
			pointB = newArray(x_points[i+1],y_points[i+1]);
			distance = getLength( pointA, pointB);
		}
		
		if(distance > max_distance){
			max_distance = distance;
			max_i = i;
		}
		if(showDebug){
			print(pointA[0]+"  "+pointA[1]+" to "+pointB[0]+"  "+pointB[1]+": "+distance);
		}
	}
	if(showDebug){
		print("Max distance: "+max_distance+" at "+max_i);
	}
	// we now have the position just before the discontinuity
	// chop the array in two and reassemble in the correct order
	x1 = Array.slice(x_points,max_i+1); // max_i to end
	y1 = Array.slice(y_points,max_i+1);
		
	x2 = Array.slice(x_points,0,max_i+1);
	y2 = Array.slice(y_points,0,max_i+1);
	
	if(showDebug){
		
		x1roi = createROI(x1, y1);
		print("Array x1:");
		drawROI(x1roi, "freeline");
		printROI(x1roi);

		x2roi = createROI(x2, y2);
		print("Array x2:");
		drawROI(x2roi, "freeline");
		printROI(x2roi);
		
	}
	
	x_final = Array.concat(x1,x2);
	y_final = Array.concat(y1,y2);

	// transfer to ROI format
	full_array = createROI(x_final, y_final);
	
	if(showDebug){
		print("Combined array:");
		drawROI(full_array, "freeline");
		printROI(full_array);
	}
	return full_array;
}

function trimROI(roi, amount_to_keep){
	x_points = ROI_to_x(roi);
	y_points = ROI_to_y(roi);
	roi_length = roi[0];
	
	end = floor(roi_length*amount_to_keep); // fetch first x% of signals
	trimmed_x = Array.slice(x_points, 0, end);
	trimmed_y = Array.slice(y_points, 0, end);
	
	trimmed_roi = createROI(trimmed_x, trimmed_y);
	return trimmed_roi;
	
}

function flipROI(roi, axis){

	// flip the ROI on one or other axis
	// return an ROI
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	
	if(axis == "x"){
		// horizontal flip
		midpoint = (x[0] + x[x.length-1]) / 2;
		flipped_x = newArray(x.length);
		
		for(i=0;i<x.length;i++){
		
			if(x[i] > midpoint){
				new_x = midpoint - (x[i]-midpoint);
			} else {
				new_x = midpoint + (midpoint - x[i]);
			}
			
			flipped_x[i] = new_x;
		}
		flipped_array = createROI(flipped_x, y);
	}
	if(axis == "y"){
		//vertical flip
		midpoint = (y[0] + y[y.length-1]) / 2;
		flipped_y = newArray(y.length);
		
		for(i=0;i<y.length;i++){
		
			if(y[i] > midpoint){
				new_y = midpoint - (y[i]-midpoint);
			} else {
				new_y = midpoint + (midpoint - y[i]);
			}
			
			flipped_y[i] = new_y;
		}
		flipped_array = createROI(x, flipped_y);
	}
	return flipped_array;
}

function drawROI(roi, type){
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	makeSelection(type, x, y);
	roiManager("Add");
}

function drawSmoothROI(roi, type){
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	makeSelection(type, x, y);
	run("Interpolate", "interval=1 smooth");
	roiManager("Add");
}

function writeROI(roi, file){
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	
	for(i=0;i<x.length;i++){
		print(file, x[i]+"\t"+y[i]);
	}
}

function printROI(roi){
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	
	for(i=0;i<x.length;i++){
		print(x[i]+"   "+y[i]);
	}
}

function swapXandYinROI(roi){
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	newROI = createROI(y, x);
	return newROI;
}

function normaliseROI(roi, newLength){
	// stretch the x coordinates of the given roi to fit from 
	// 0 - length allowing comparison between different curves
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	old_x_max = 0;
	
	max_y = 0; // for logging
	
	for(i=0;i<x.length;i++){
		if(x[i] > old_x_max){
			old_x_max = x[i];
		}
		if(y[i] > max_y){ // for logging
			max_y = y[i];
		}
	}
	
	addToLog("MY",max_y);
	
	for(i=0;i<x.length;i++){
		x[i] = (x[i] / old_x_max) * newLength;
	}
	newROI = createROI(x,y);
	return newROI;	
}

function getROIArea(roi){
	
	drawROI(roi, "polygon");

	run("Set Measurements...", "area");
	run("Measure");
	
	if(nResults > 0){
		a = getResult("area"); // centre of mass
	}
	return a;
}

// -------------------------------------------------
// GENERAL FUNCTIONS
// -------------------------------------------------
function getLength(pointA, pointB) {
	dx = pointB[0]-pointA[0]; 
	dy = pointB[1]-pointA[1];
	length = sqrt(dx*dx+dy*dy);
	return length;
}

function getX(eq, y){
	// x = (y-c)/m
	x = (y - eq[1]) / eq[0];
	return x;
}

function getY(eq, x){
	// y = mx +c
	y = (eq[0] * x) + eq[1];
	return y;
}

function getLineCoordinates(eq, w, h){
	
	// the start and end points of the line may be offscreen for given x coordinates
	// find the best start and end points
	x_start = 0;
	x_end = w - 1;
	
	y_start = getY(eq, x_start); // (eq[0] * 1) + eq[1];
	y_end =  getY(eq, x_end); //(eq[0] * (w - 1)) + eq[1];
	
	// write("Ideal line: "+x_start+","+y_start+" to "+x_end+","+y_end);
		
	if(y_start > h - 1){ // too high
		x_start = getX(eq, h - 1);
		y_start = h - 1;
		
	}
	if(y_start < 0){ 
		x_start = getX(eq, 0);
		y_start = 0;
	}
	
	if(y_end > h - 1){
		x_end = getX(eq, h - 1);
		y_end = h - 1;
	}

	if(y_end < 0){ 
		x_end = getX(eq, 0);
		y_end = 0;
	}
	// write("Final line: "+x_start+","+y_start+" to "+x_end+","+y_end);
	result=newArray(x_start, y_start, x_end, y_end);
	return result;
}

function calculateLineEquation(position_1, position_2){
	
	delta_x = position_1[0] - position_2[0];
	delta_y = position_1[1] - position_2[1];
	
	m = delta_y / delta_x;
	
	// y - y1 = m(x - x1)
	c = position_1[1] -  ( m * position_1[0] );
	
	testy = (m * position_2[0]) + c;
	
	// write("y = "+m+"x + "+c);
	result=newArray(m, c);
	return result;
	
}

function addToLog(field, value){
	
	logFields = Array.concat(logFields, field);
	logValues = Array.concat(logValues, value);
}

function printLog(file){
	
	print(file, "~ ------------------");
	// print(file, "# LOGGED PARAMETERS");
	// print(file, "# ------------------");
	for(i=0;i<logFields.length;i++){
		print(file, logFields[i]+"~"+logValues[i]);
	}
}

function emptyLog(){
	logFields = newArray();
	logValues = newArray();
}

function checkLogFilePath(logDir, logFileName, n){
	
	logFile = logDir + "//" + logFileName + "." + n +".txt";
	if(File.exists(logFile)){
		n++;
		logFile = checkLogFilePath(logDir, logFileName, n);
	}
	return logFile;
}

// -------------------------------------------------
// DRAWING FUNCTIONS
// -------------------------------------------------
function drawRectangleAtPoint(point, colour){
	// a rectangle at x-1, y-1, 3x3 square so centred on x,y
	setColor(colour);
	drawRect(point[0]-1, point[1]-1, 3, 3); 
}

function drawLineBetweenPoints(pointA, pointB, colour){
	
	setColor(colour);
	drawLine(pointA[0], pointA[1], pointB[0], pointB[1]);
}
