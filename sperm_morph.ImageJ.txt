/*
Copyright (C) Ben Skinner 2014
-------------------------------------------------
MOUSE SPERM MORPOLOGY ANALYSIS
-------------------------------------------------
This script uses DAPI signal.
Nuclear organisation script technique is used to find the 
axes head-tail and hook-hump.

The head-hump border is extracted from the hump-side ROI
(70% of ROI boundary beginning at head)

The resulting ROI is rotated and flipped to put the head directly
above the tail end of the curve, with the hump on the left. This curve is translated
to zero axis coordinates. X and Y coordinates are swapped to make the curve horizontal.
This allows for simple plotting and drawing best fit lines in excel. Coordinates for
the curve are given in the log window.
-------------------------------------------------
LOGGED FIELDS:
-------------------------------------------------
CL Curve length
NA Nuclear area
NP Nuclear perimeter
FD Feret diameter
MY Max Y
IN Image name
ID Image directory
LFA Angle log file
LFS Shuffled angle log
ASP Angle spacing
Curve y = a+bx+cx^2
XA = a
XB = b
XC = c
XR = r^2
RA = raw a
RB = raw b
RC = raw c
RR = raw r^2
-------------------------------------------------
BUGS:
-------------------------------------------------

-------------------------------------------------
TODO:
-------------------------------------------------
We can detect the tip using angles.
We know the tail must be about half way round.
Therefore exclude all angles within 25% of perimeter
either side of the tip
Find the next lowest point. This is the sharpest corner of
the tail
	Shuffle ROI to put tip at front.
	Remove 25% front and back
-------------------------------------------------
REQUIRES:
-------------------------------------------------
<plugins>/Nuclear_Organisation/ included in startup macros:
   
   macro "AutoRun" {

  // set the path to the shared functions library
  path = getDirectory("plugins")+"Nuclear_Organisation/";
  all_functions = ""; // string to hold all imported functions

  list = getFileList(path);

  // define the function files to use
  for (i=0; i<list.length; i++) {

    if (endsWith(list[i], ".js")) {
      
      all_functions = all_functions + File.openAsString(path+list[i]);
    } 
  }

  // add to imageJ as functions
  call("ij.macro.Interpreter.setAdditionalFunctions", all_functions);
}


*/

// nucleusThresholdLevel determines the segmentation level for separating the cell from
// the background
var nucleusThresholdLevel = 45; // set to work on images from Kent - 2014-11-03

// nucleusMin is the minimum number of pixels that a nucleus contains 
// (based on mouse sperm)
var nucleusMin = 400; 
var nucleusMax = 3000;

// the array of information to log
var logFields = newArray();
var logValues = newArray();

var showDebug = true; // show debugging info

function analysesOfMorphology(){

	// get the total nuclear ROI

	// perform the angle measurements
	// find the tip
	// find max diameter from tip = tail 
	// make an roi with the tip at the beginning
	// carry out width measurements
	// length / feret length
	// get the curve roi
	// carry out the curve measurements
	// get the tail roi
	// tail curvature
}

function initialiseLogging(){

	emptyLog();
	logDir = getInfo("image.directory");
	addToLog("ID", logDir);
	addToLog("IN", getInfo("image.filename"));

	if(showDebug){ print("Log file = "+getLogValue("IN") ); }
	logFileName = getLogValue("IN");
	logFileName = logFileName+".main";
		
	logFile = checkLogFilePath(logDir, logFileName, 1);
	addToLog("LF", logFile);

	angleFileName = logFileName+".angles";	
	angleFile = checkLogFilePath(logDir, angleFileName, 1);
	addToLog("LFA", angleFile);

	shuffAngleFileName = logFileName+".shuff.angles";
	shuffAngleFile = checkLogFilePath(logDir, shuffAngleFileName, 1);
	addToLog("LFS", shuffAngleFile);

	diffAngleFileName = logFileName+".diff.angles";
	diffAngleFile = checkLogFilePath(logDir, diffAngleFileName, 1);
	addToLog("LDA", diffAngleFile);

	f = File.open(logFile);
	return f;
}

function main() {

	// get a file handle
	f = initialiseLogging();

	// click a pixel inside the nucleus
	location_on_image = selectNucleus();
			
	copyAndSplit();
	close("working (red)");

	// find the nuclear ROI at the given location
	nucleus_roi = findNuclearROI(location_on_image);
	
	// carry out angle based analysis as alternative to feret line approach
	// for finding the features of interest in the sperm
	// analyseAngles(nucleus_roi);

	// figure out where the hook tip is located
	// create an ROI for the curve
	initial_roi = getAcrosomalCurve(nucleus_roi);

	
	// rotate the ROI until head and tail are vertically aligned
	rotated_roi = alignHeadandTailOnX(initial_roi);
	
	// ensure the head is at the top - flip y if needed
	oriented_roi = putHeadOnTop(rotated_roi);
	drawROI(oriented_roi, "polygon");
	
	// draw head point
	// remember y axis is reversed for images
	// drawSpermTip(oriented_roi);
	
	// check if the left of the midpoint is within roi
	// if not, flip on x axis
	oriented_roi = putHumpOnLeft(oriented_roi);
	drawSmoothROI(oriented_roi, "freeline");
	// writeROI(final_roi);
	// drawSpermTip(final_roi);
		
	// swap x and y coordinates to make a horizontal roi
	complete_roi = swapXandYinROI(oriented_roi);
	
	// put the sperm head at x=0
	complete_roi = flipROI(complete_roi, "x");
	
	if(showDebug){ print("Flipped:");}
	// writeROI(complete_roi);
	 
	// offset the ROI to start at 0,0
	complete_roi = offsetToZeroROI(complete_roi);
	// print("Offset:");
	// writeROI(complete_roi);
	raw_roi = complete_roi;
	
	// normalise curve length to 100 pixels
	complete_roi = normaliseROI(complete_roi, 100);
	
	drawSmoothROI(complete_roi, "freeline");
	drawSpermTip(complete_roi);
	
	doCurveFit(complete_roi);
	doRawCurveFit(raw_roi);
	
	if(showDebug) { print("# ------------------");}
	if(showDebug) { print("# END DEBUG LOG"); }
	if(showDebug) { print("# ------------------"); }
	
	printLog(f);
	
	print(f, "# x\ty\tx_raw\ty_raw"); // the column headers
	writeDualROI(complete_roi, raw_roi, f);
	
	print(f, "# END OF FILE");
	
	close("working*");
	close("spare*");
	close("Calibrating*");
	if(!showDebug){
		close("draw");
	}
	File.close(f);
}


// Given a point and an ROI, find the place on the ROI
// that is furthest from the point of interest
// Input: point  - array (x,y)
// 		  roi 	 - ROI array
// Returns: point [array (x,y)]
function findLongestDiameter(point, roi){

	x = ROI_to_x(roi);
	y = ROI_to_y(roi);

	max_distance = 0;
	max_point = point;

	for (i = 0; i < x.length; i++) {
		
		new_point = newArray(x[i],y[i]);
		distance = getLength(point, new_point);
		if(distance > max_distance){
			max_distance = distance;
			max_point = new_point;
		}		
	}
	print("Sperm tail is at: "+max_point[0]+"   "+max_point[1]+" with max diameter "+max_distance);
	return max_point;
}

// Given an AngleROI, find the coordinates with 
// minimum angle. This is the sperm tip.
// Input: array  - AngleROI
// Returns: array (x,y, angle)
function findSpermTip(array){

	// based on angle array
	// sperm tip has the lowest angle
	min_angle = 180;
	min_index = 0;

	checkangles = AngleROI_to_angle(array);
	for (i=0; i<checkangles.length; i++) {
		
		if(checkangles[i] < min_angle){
			min_angle = checkangles[i];
			min_index = i;
		}
	}
	values = getValuesAtMultiDimensionalArrayIndex(array, min_index);
	print("Sperm tip is at: "+values[0]+"    "+values[1]+" with angle: "+values[2]);
	return values;
}

// Given an ROI, find the tail of the sperm head (second lowest local minimum)
// Input: roi - ROI array
// Returns: point  [array (x,y)]
function processAngleArrayFurther(roi){

	// shuffle the ROI to put the sperm tip first
	// x = ROI_to_x(roi);
	// y = ROI_to_y(roi);

	// roi = createROI(x, y);

	// for(space=23;space<24;space+=2){
		space = 23;
		array = makeAngles(roi, 1, space); // with smoothing
	

		// copied from findSpermTip
		min_angle = 180;
		min_index = 0;

		checkangles = AngleROI_to_angle(array);
		for (i=0; i<checkangles.length; i++) {
			
			if(checkangles[i] < min_angle){
				min_angle = checkangles[i];
				min_index = i;
			}
		}
		// print("Found min index is "+min_index+" at angle "+min_angle);
		values = getValuesAtMultiDimensionalArrayIndex(array, min_index);
		print("Low point is at: "+values[0]+", "+values[1]+" with angle: "+values[2]);

		tip_point = findClosestPointOnROI(values, roi);
		print("Sperm tip is at: "+tip_point[0]+", "+tip_point[1]);

		new_array = shuffleAngleROI(array, min_index);
		// printMultiDimensionalArray(new_array, getLogValue("LFS"));

		// caclulateDerivativeAngles(new_array);

		// find local minima for range of window sizes and export
		minima_array = detectLocalMinima(new_array);
		// printMultiDimensionalArray(minima_array, getLogValue("LFS"));

		// get the minima from the array
		minima_array = extractMinima(minima_array);
		// Array.print(minima_array);
		// rank minimas by angle
		minima_array = sortMultiDimensionalArray(minima_array, 3, "asc");
		Array.print(minima_array);

		// exclude points overlapping head
		// find closest xy point to the next lowest (remember we have smoothed)
		data = getValuesAtMultiDimensionalArrayIndex(minima_array, 1);
		print("Low point at "+data[0]+", "+data[1]+" with angle "+data[2]);

		tail_point = findClosestPointOnROI(data, roi);
		print("Sperm tail is at "+tail_point[0]+", "+tail_point[1]);
		
		if(showDebug){
			selectWindow("draw");
			drawRectangleAtPoint(tail_point, "white");
		}
		
	// }
	// TODO: How do we decide which is the best of the window sizes?
	return tail_point;
}

// Given an ROI array with integers, and a floating point single point,
// find the position in the ROI that is closest. Use to convert points found in smoothed
// ROIs back to unsmoothed ROI coordinates
// Input: point  - array (x,y)
// 		  roi 	 - ROI array
// Returns: point [array (x,y)]
function findClosestPointOnROI(point, roi){

	x = ROI_to_x(roi);
	y = ROI_to_y(roi);

	min_index = 0;
	min_dist = 100;

	for (i=0; i<x.length; i++) { 

		test_point = newArray(x[i], y[i]);
		distance = getLength(point, test_point);

		if(distance<min_dist){
			min_dist = distance;
			min_index = i;
		}
	}

	result = newArray(x[min_index],y[min_index]);
	return result;
}

// Extract points declared as local minima from a multicolumn array
// and return the points as an AngleROI
// Input: multi dimensional array with minima in final column
// Returns: AngleROI_array
function extractMinima(array){

	max_dimension = array[1];

	x = readMultiDimensionalArray(array, 1);
	y = readMultiDimensionalArray(array, 2);
	a = readMultiDimensionalArray(array, 3);
	m = readMultiDimensionalArray(array, max_dimension);

	new_x = newArray();	new_y = newArray();	new_a = newArray();


	for (i=0; i<x.length; i++) {

		if(m[i] == 1){ // this is a minimm
			new_x = Array.concat(new_x, x[i]);
			new_y = Array.concat(new_y, y[i]);
			new_a = Array.concat(new_a, a[i]);

			if(showDebug){ 
				selectWindow("draw");
				point = newArray(x[i], y[i]);
				drawRectangleAtPoint(point, "yellow");
			}
		}
	}

	result = createAngleROI(new_x, new_y, new_a);
	return result;
}

// Given an AngleROI array, find points with local minima
// Input: AngleROI_array
// Returns:  Multi dimensional array (AngleROI plus minima boolean in final column)
function detectLocalMinima(array){

	// go through angle array (with tip at start)
	// look at 1-2-3-4-5 points ahead and behind.
	// if all greater, local minimum
	x = AngleROI_to_x(array);
	y = AngleROI_to_y(array);
	a = AngleROI_to_angle(array);

	lookups = newArray(5,6); // 4-5-6-7 points ahead and behind

	newarray = createMultiDimensionalArray(x.length, lookups.length + 3); // x, y, a plus the number of window sizes
	newarray = populateMultiDimensionalArray(newarray, x, 1);
	newarray = populateMultiDimensionalArray(newarray, y, 2);
	newarray = populateMultiDimensionalArray(newarray, a, 3);
	
	for(lookup=0;lookup<lookups.length;lookup++){

		prev_a = newArray(lookups[lookup]); // slots for previous angles
		next_a = newArray(lookups[lookup]); // slots for next angles

		ok_array = newArray(x.length); // array to hold an ok for each position in sperm

		for (i=0; i<x.length; i++) { // for each position in sperm

			// go through each lookup position and get the appropriate angles
			for(j=0;j<prev_a.length;j++){


				prev_i = i-(j+1);
				next_i = i+(j+1);

				// handle beginning and end of array - wrap around
				if(prev_i < 0){
					prev_i = x.length + prev_i;
				}
				if(next_i >= x.length){
					next_i = next_i - x.length;
				}

				// fill the lookup array
				prev_a[j] = a[prev_i];
				next_a[j] = a[next_i];
			}
			
			// with the lookup positions, see if minimum at i
			// return a 1 if all higher than last, 0 if not
			// prev_l = 0;
			ok = 1;
			for(l=0;l<prev_a.length;l++){

				// not ok if the outer entries are not higher than inner entries
				if(l==0){
					if(prev_a[l] < a[i] || next_a[l] < a[i]){
						ok = 0;
					}
				} else {
					
					if(prev_a[l] < prev_a[l-1] || next_a[l] < next_a[l-1]){
						ok = 0;
					}
				}
			}

			// put oks into array to put into multiarray
			ok_array[i] = ok;

		}
		// add ok to correct point in multi array - gives determination of local minimum
		newarray = populateMultiDimensionalArray(newarray, ok_array, lookup+4);
	}
	return newarray;
}

// function caclulateDerivativeAngles(array){

// 	x = AngleROI_to_x(array);
// 	y = AngleROI_to_y(array);
// 	a = AngleROI_to_angle(array);
// 	diffs = newArray();

// 	newarray = createMultiDimensionalArray(x.length, 4);
	
// 	prev_a = 0;
// 	for (i=0; i<x.length; i++) {
// 		if(i==0){
// 			a_diff = a[i] - a[x.length-1];

// 		} else {
// 			a_diff = a[i] - prev_a;
// 		}

// 		prev_a = a[i];

// 		diffs = Array.concat(diffs, a_diff);
// 	}

// 	newarray = populateMultiDimensionalArray(newarray, x, 1);
// 	newarray = populateMultiDimensionalArray(newarray, y, 2);
// 	newarray = populateMultiDimensionalArray(newarray, a, 3);
// 	newarray = populateMultiDimensionalArray(newarray, diffs, 4);
// 	printMultiDimensionalArray(newarray, getLogValue("LDA"));

// }


function makeAngles(roi, smooth, spacing){

	x = ROI_to_x(roi); // should be core function
	y = ROI_to_y(roi);

	if(smooth == 1){
		// smoothig allows for easier min/max detection
		makeSelection("freeline", x, y);
		run("Interpolate", "interval=1 smooth");
		getSelectionCoordinates(x, y);
	}

	// consider using distance to CoM to determine curve orientation
	// increaseing distance = outer curve
	// decreasing = inner curve

	// spacing = 25; // magic number. Make function to detect it.
	addToLog("ASP", spacing);
	midpoint = (spacing+1) /2;

	// wrap the array at the end
	re_x = Array.slice(x,0,spacing);
	re_y = Array.slice(y,0,spacing);

	x = Array.concat(x,re_x); // merge beginning of array onto end for wrap
	y = Array.concat(y,re_y);

	// the three points to measure
	old_x = newArray();
	old_y = newArray();
	angles = newArray();

	if(showDebug) { print("Angles with spacing "+spacing+":"); }

	for(i=0;i<x.length;i++){

		if(i<spacing){
			old_x = Array.concat(old_x, x[i]);
			old_y = Array.concat(old_y, y[i]);
			continue;
		}

		old_x = Array.slice(old_x,1);
		old_x = Array.concat(old_x, x[i]);

		old_y = Array.slice(old_y,1);
		old_y = Array.concat(old_y, y[i]);

		xcoords = newArray(old_x[0], old_x[midpoint], old_x[spacing-1]);
		ycoords = newArray(old_y[0], old_y[midpoint], old_y[spacing-1]);
		
		makeSelection("angle", xcoords, ycoords);
		run("Measure");		
		angle = getResult("Angle");

		File.append(old_x[midpoint]+"\t"+old_y[midpoint]+"\t"+angle, getLogValue("LFA")); 

		// if(showDebug) { print(old_x[midpoint]+"   "+old_y[midpoint]+"   "+angle); }

		angles = Array.concat(angles, angle);

	}
	x = Array.slice(x,spacing);
	y = Array.slice(y,spacing);

	angle_end = Array.slice(angles,0,midpoint-2);
	angle_start = Array.slice(angles,midpoint-2);
	angles = Array.concat(angle_start, angle_end);

	angleArray = createAngleROI(x, y, angles);
	if(showDebug) { print("Multidimensional array: length: "+angleArray[0]+"  dimensions: "+angleArray[1]); }
	return angleArray;
}

function doCurveFit(roi){

	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	
	Fit.doFit(1, x, y); // 1 is 1st Degree Polynomial
	// Fit.plot();
	// rename("Calibrating curve");

	a = Fit.p(0);
	b = Fit.p(1);
	c = Fit.p(2);
	r2 = Fit.rSquared;
	
	addToLog("XA", a);
	addToLog("XB", b);
	addToLog("XC", c);
	addToLog("XR", r2);
}

function doRawCurveFit(roi){

	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	
	Fit.doFit(1, x, y); // 1 is 1st Degree Polynomial
	// Fit.plot();
	// rename("Calibrating curve");

	a = Fit.p(0);
	b = Fit.p(1);
	c = Fit.p(2);
	r2 = Fit.rSquared;
	
	addToLog("RA", a);
	addToLog("RB", b);
	addToLog("RC", c);
	addToLog("RR", r2);
}

function putHumpOnLeft(roi){
	y = ROI_to_y(roi);
	x = ROI_to_x(roi);
	midpoint = (y[0] + y[y.length-1]) / 2;
	
	if(selectionContains(x[0]-2,midpoint)){
		// hump is on left
		// continue
		flipped = roi;
	} else {
		// hump is on right
		// flip on x axis
		flipped = flipROI(roi, "x");
	}
	return flipped;	
}

function alignHeadandTailOnX(selection){
	x_points = ROI_to_x(selection);
	y_points = ROI_to_y(selection);
	min_x = 100;
	theta = 0;
	
	for(i=1;i<180;i++){
		// always do the rotation fresh on original coordinates
		// avoids distortion from integer positions building up
		makeSelection("freeline", x_points, y_points);
		// run("Interpolate", "interval=1 smooth");
		run("Rotate...", "angle="+i);
		getSelectionCoordinates(rot_x, rot_y);
		head_to_tail_x = abs(rot_x[0] - rot_x[rot_x.length-1]);
		// print(i+" degrees: "+head_to_tail_x);
		if(head_to_tail_x < min_x){
			min_x_roi = createROI(rot_x, rot_y);
			theta = i;
			min_x = head_to_tail_x;
		}
	}
	if(showDebug) { print("Minimum distance: "+min_x);}
	if(showDebug) { print("Rotated by "+theta+" degrees");}
	return min_x_roi;
}

function putHeadOnTop(roi){
	
	y_points = ROI_to_y(roi);
	if(showDebug) { print("Head: "+y_points[0]+" Tail"+y_points[y_points.length-1]);}
	if(y_points[0] < y_points[y_points.length-1]){
		// flip it
		if(showDebug) { print("Flipping");}
		flipped_roi = flipROI(roi, "y");
	} else {
		flipped_roi = roi;
	}
	return flipped_roi;
}

// Given a location in an image, find the ROI
// that corresponds to the nucleus at this location
// Input: point [array(x,y)]
// Returns: ROI
function findNuclearROI(location) {
	// identifies the outline of the sperm nucleus
	
	selectWindow("working (blue)");
	blueID = getImageID();
	
	run("Duplicate...", "title=spare_blue");

	// find the centre of the nucleus
	nucleus_roi = makeROIFromPoint(location, blueID);
		
	drawROI(nucleus_roi, "freeline");
	
	if(showDebug) { print("# ------------------");}
	if(showDebug) { print("# BEGIN DEBUG LOG");}
	if(showDebug) { print("# ------------------");}
	if(showDebug) { print("Found nucleus ROI");}

	return nucleus_roi;
}

function getAcrosomalCurve(nucleus_roi) {

	// finds the axes head-tail and hook-hump
	// returns an roi from tip across the hump

	// get the centre of mass of the nucleus
	nucleus_centre = findNucleusCentreOfMass(nucleus_roi);
	if(showDebug) { print("Nucleus CoM: "+nucleus_centre[0]+"    "+nucleus_centre[1]);}

	// make and export the angles at 25 pixel spacing
	// around the nucleus
	angle_array = makeAngles(nucleus_roi, 0, 25);

	// based on the array of angles, find the sperm tip.
	// It will have the lowest angle
	sperm_tip = findSpermTip(angle_array);
	sperm_tail = processAngleArrayFurther(nucleus_roi);

	// processAngleArrayFurther(angle_array);

	// find the feret line of the nucleus
	// feret_line = findFeretsDiameter(nucleus_roi); // gets the positions on the border of the feret line
	// if(showDebug) {
	// 	// selectWindow("draw");
	// 	// point1 = newArray(feret_line[0], feret_line[1]);
	// 	// point2 = newArray(feret_line[2], feret_line[3]);
	// 	// drawLineBetweenPoints(point1, point2, "yellow");
	// 	print("Drew Feret line");
	// 	// waitForUser("Feret drawn");
	// }

	// // find the max diameter line from the sperm tip (not always feret line)
	// max_point = findLongestDiameter(sperm_tip, nucleus_roi);
	// max_line = Array.concat(sperm_tip, max_point);

	// if(showDebug) {
	// 	print("Max point: "+max_point[0]+"   "+max_point[1]);
	// 	// selectWindow("draw");
	// 	// drawLineBetweenPoints(sperm_tip, max_point, "white");
	// }
		
	// // get the orthogonal-to-feret line through centre of mass
	// orth_line = findOrthogonalToFeretLine(nucleus_centre, feret_line);
	// // orth_line = findOrthogonalToFeretLine(nucleus_centre, max_line);
	// if(showDebug) {
	// 	print("Orth line: "+orth_line[0]+"   "+orth_line[1]+" to "+orth_line[2]+"   "+orth_line[3]);
	// }

	
	// // decide which end of the line is at the tip of the sperm
	// // based on distance from CoM to points
	// tail_point = findSpermTailPoint(orth_line, feret_line);
	// replace old methods here
	tail_point = sperm_tail;

	// combine the tip point detected by angle with the tail point detected by orth line
	head_point = newArray(sperm_tip[0],sperm_tip[1]);
	improved_feret_line = Array.concat(head_point, tail_point);
	if(showDebug) {
		print("Hybrid feret line: "+improved_feret_line[0]+"   "+improved_feret_line[1]+" to "+improved_feret_line[2]+"   "+improved_feret_line[3]);
		selectWindow("draw");
		drawLineBetweenPoints(head_point, tail_point, "yellow");
	}
	
	// splits the nucleus roi in two along the feret line and returns hump roi coordinates
	hump_roi = splitROIs(improved_feret_line, nucleus_roi); 
	// hump_roi = splitROIs(feret_line, nucleus_roi); // splits the nucleus roi in two along the feret line and returns hump roi coordinates
	// if(showDebug){
	// 	printROI(hump_roi);
	// 	print("Completed split");
	// }
	// writeROI(hump_roi);
	selectWindow("draw");
	
	drawROI(hump_roi, "freeline");
	
	// order the roi to make sure we start the array on the tip of the sperm
	// ordered_roi = shuffleROI(hump_roi, head_point);
	ordered_roi = shuffleROI(hump_roi);
	drawROI(ordered_roi, "freeline");
	if(showDebug){
		print("Shuffled hump ROI:");
		// printROI(hump_roi);
	}
	
	
	// trim the roi
	// need to determine which end is the tip
	// ordered_roi = checkOrientation(ordered_roi, head_point);
	// ordered_roi = checkOrientation(ordered_roi, head_point);
	ordered_roi = checkOrientation(ordered_roi, sperm_tip);
	if(showDebug) { print("ROI ordered");}
	
	// fetch first 70% of signals
	trimmed_roi = trimROI(ordered_roi, 0.7);
	
	// roiManager("reset");
	drawROI(trimmed_roi, "freeline");
	run("Set Measurements...", "length");
	run("Measure");
	if(nResults > 0){
		length = getResult('Length');
		addToLog("CL", length);
	}
	if(showDebug) { print("ROI trimmed");}
	
	run("Clear Results");
	return trimmed_roi;
}

function findSpermTailPoint(orth_line, feret_line){
	// measure from the crossing point of orth and feret lines to the ends of the feret line;
	// decide which is smaller - assume that is the tail side
	orth_crossing = newArray(orth_line[4], orth_line[5]);
	feret1 = newArray(feret_line[0], feret_line[1]);
	feret2 = newArray(feret_line[2], feret_line[3]);
	
	feret1_dist = getLength(orth_crossing, feret1);
	feret2_dist = getLength(orth_crossing, feret2);
	
	if(feret1_dist >= feret2_dist){
		head_point = feret1;
		tail_point = feret2;
	} else {
		head_point = feret2;
		tail_point = feret1;
	}
	if(showDebug) { write("Decided head is at : "+head_point[0]+","+head_point[1]);}
	if(showDebug) { write("Decided tail is at : "+tail_point[0]+","+tail_point[1]);}
	return tail_point;
}

function checkOrientation(roi, head_point){

	x_points = ROI_to_x(roi);
	y_points = ROI_to_y(roi);
	end_x = x_points[x_points.length-1];
	end_y = y_points[y_points.length-1];
	
	if(x_points[0] == head_point[0] && y_points[0] == head_point[1]){
		// flip = 0;
		if(showDebug) { print("Tip is at top of array; leaving");}
	} else if(end_x == head_point[0] && end_y == head_point[1]){
		// flip = 1;
		if(showDebug) { print("Tip is at bottom of array; reversing");}
		// reverse the arrays if needed to put tip at beginning
		x_points = Array.reverse(x_points);
		y_points = Array.reverse(y_points);
	} else {
		if(showDebug) { print("Cannot determine orientation");}
	}
	new_roi = createROI(x_points, y_points);
	
	return new_roi;
}

function findNucleusCentreOfMass(roi) {
	// returns x,y, area
	selectImage("working (blue)");
	run("Duplicate...", "title=temp"); //a copy of the primary image
	selectImage("temp");
	// setThreshold(nucleusThresholdLevel, 255); // masks

	drawROI(roi, "polygon");

	run("Set Measurements...", "area center centroid feret");
	run("Measure");
	
	if(nResults > 0){
		nucleus_x = getResult("XM"); // centre of mass
		nucleus_y = getResult("YM");
		area = getResult("Area");
		  		
		result=newArray(nucleus_x, nucleus_y, area);
		run("Clear Results");
	} else {
		result = newArray();
		print("Could not get measurements of nucleus");
	}
	addToLog("NA", area);

	close("temp");
	return result;
}

// Given an ROI, find the longest diameter
// Input: ROI
// Returns: Array defining start and end points of line [array(x1,y1,x2,y2)]
function findFeretsDiameter(roi) {
    
    diameter = 0.0;
	x = ROI_to_x(roi);
	y = ROI_to_y(roi);

	i1 = 0;
	i2 = 0;

	for (i=0; i<x.length; i++) {

		point1 = newArray(x[i], y[i]);

		for (j=i; j<x.length; j++) {

			point2 = newArray(x[j], y[j]);

			d = getLength(point1, point2);			
			if (d>diameter) {
                diameter = d;
                i1 = i;
                i2 = j;
            }
        }
    }

	result = newArray(x[i1], y[i1],x[i2],y[i2]);
	if(showDebug) { 
		point1 = newArray(result[0],result[1]);
		point2 = newArray(result[2],result[3]);
		print("Detected Feret diameter: "+diameter);
		print("Feret from: "+point1[0]+"    "+point1[1]+" to "+point2[0]+"    "+point2[1]);
	}
	addToLog("FD", diameter);
	return result;
}

function splitROIs(line, roi) {

	// splits the nucleus roi in two along a given line 
	// return the outline of the hump side roi

	// line is array: xy, xy

	xCoordinates = ROI_to_x(roi);
	yCoordinates = ROI_to_y(roi);
	// print("Got x and y");
	
	// new arrays for the split roi coordinates
	roi1X = newArray();	roi1Y = newArray();
	roi2X = newArray();	roi2Y = newArray();
	
	roi1 = 1;
	roi2 = 0;
	for (i=0; i<xCoordinates.length; i++) { // go through the selection border coords
				
		// add to current roi
		if(roi1 == 1){
			roi1X = Array.concat(roi1X, xCoordinates[i]);
			roi1Y = Array.concat(roi1Y, yCoordinates[i]);
		}
		
		if(roi2 == 1){
			roi2X = Array.concat(roi2X, xCoordinates[i]);
			roi2Y = Array.concat(roi2Y, yCoordinates[i]);
		}
		
		// if we hit the line, switch from roi1 to roi2 and or back	
		if( (xCoordinates[i] == line[0] && yCoordinates[i] ==  line[1]) || (xCoordinates[i] == line[2] && yCoordinates[i] ==  line[3]) ) {
			


			if(showDebug){
				print("Splitting ROI at: "+xCoordinates[i]+" "+yCoordinates[i]);
			}

			// if(!roi1){ // ensure the feret coordinates are included in the new roi even if the roi bit is not true
				// roi1X = Array.concat(roi1X, xCoordinates[i]);
				// roi1Y = Array.concat(roi1Y, yCoordinates[i]);
			// }
			// if(!roi2){
				// roi2X = Array.concat(roi2X, xCoordinates[i]);
				// roi2Y = Array.concat(roi2Y, yCoordinates[i]);
			// }
			
			// flip roi1 and roi2
			roi1 = !roi1;
			roi2 = !roi2;
		}
		
	}

	if(showDebug){
		print("Made the split");

	}
	
	selectImage("spare_blue");
	// create new roi out of roi1 and roi2
	// roi1_array = createROI(roi1X, roi1Y);
	// print("Made roi1");
	makeSelection("polygon", roi1X, roi1Y);
	run("Measure");
	// print("Measured");
	area1 = getResult("Area");
	cent1x = getResult("X");
	cent1y = getResult("Y");
	
	// roi2_array = createROI(roi2X, roi2Y);
	makeSelection("polygon", roi2X, roi2Y);
	run("Measure");
	area2 = getResult("Area");
	cent2x = getResult("X");
	cent2y = getResult("Y");	

	// roiManager("reset");
	if(area1 >= area2){
		// roi1X = Array.slice(roi1X,1,roi1X.length-2);
		// roi1Y = Array.slice(roi1Y,1,roi1Y.length-2);
		list = createROI(roi1X, roi1Y);
	} else {
		// roi2X = Array.slice(roi2X,1,roi2X.length-2);
		// roi2Y = Array.slice(roi2Y,1,roi2Y.length-2);
		list = createROI(roi2X, roi2Y);
	}
	if(showDebug){
		print("Decided which side is hump:"+area1+" vs "+area2);
	}
	return list;
}

function findOrthogonalToFeretLine(centroid, feret_line){
	// centroid is the position the line must pass through at 90 degrees to feret (x,y)
	// feret_line is the coordinates of the start and end of the line (x,y,x,y)
	// returns the start and end points of the orth line, plus the feret crossing (x1,y1,x2,y2, xc, yc)
	x = newArray(feret_line[0], feret_line[2]); // arrays of the feret line bounds
	y = newArray(feret_line[1], feret_line[3]);

	makeSelection("line", x, y);
	// makeLine(feret_line[0], feret_line[1], feret_line[2], feret_line[3]); // 
	run("Fit Spline", "straighten"); 
	getSelectionCoordinates(xCoordinates, yCoordinates); // list of points on the line
	
	best_angle = 90;
	best_diff = 90;
	for(i=0; i<xCoordinates.length; i++){
		
		// draw a new line from centroid to feret start
		makeLine(centroid[0], centroid[1], xCoordinates[i], yCoordinates[i], feret_line[0], feret_line[1]);
		xcoord1 = newArray(centroid[0],  xCoordinates[i], feret_line[0]);
		ycoord1 = newArray(centroid[1],  yCoordinates[i], feret_line[1]);
		makeSelection("angle", xcoord1, ycoord1);
		run("Measure");		
		angle1 = getResult("Angle");
		
		// draw a new line from centroid to feret end
		xcoord2 = newArray(centroid[0],  xCoordinates[i], feret_line[2]);
		ycoord2 = newArray(centroid[1],  yCoordinates[i], feret_line[3]);
		makeSelection("angle", xcoord2, ycoord2);
		run("Measure");		
		angle2 = getResult("Angle");
		
		diff = abs(angle1 - angle2);
		if(  diff < best_diff ){ // try to find the point at which they are equal
			best_angle = angle1;
			best_diff = diff;
			orth = newArray(xCoordinates[i], yCoordinates[i]);
		}
		// write(angle1+"  "+angle2+"  "+diff+"  "+best_angle+"  "+xCoordinates[i]+"  "+yCoordinates[i]);
	}
	// write("Set on: "+best_angle+" at "+orth[0]+","+orth[1]);
	eq = calculateLineEquation(orth, centroid);
	line = getLineCoordinates(eq, getWidth(), getHeight());
	line = Array.concat(line, orth[0]); // add in the crossing point to the orth line results
	line = Array.concat(line, orth[1]);
	if(showDebug) { 
		selectWindow("draw");
		point1 = newArray(line[0],line[1]);
		point2 = newArray(line[2],line[3]);
		drawLineBetweenPoints(point1, point2, "white"); 
	}
	return line;	
}

function selectNucleus() {

	roiManager("reset");
	leftButton=16;
	x2=-1; y2=-1; z2=-1; flags2=-1; clickCount=0;

	point=newArray(0, 0); // x,y

	logOpened = false;
	if (getVersion>="1.37r")
		setOption("DisablePopupMenu", true);

	name=getTitle;
	
	if(!isOpen("Log")){
		print("Click a nucleus to measure");
	}
	
	while (!logOpened || isOpen("Log")) {
		getCursorLoc(x, y, z, flags);
		if (x!=x2 || y!=y2 || z!=z2 || flags!=flags2) {

			if (flags&leftButton!=0){

				clickCount++;
				if(clickCount==1){
					point[0]=x;
					point[1]=y;		
					break;
				}
			}
			logOpened = true;
			startTime = getTime();
		}
		x2=x; y2=y; z2=z; flags2=flags;
		wait(10);
	}
	if (getVersion>="1.37r")
		setOption("DisablePopupMenu", false);
		
	// print("Terminus 1 - x: " + point[0] + " y: " + point[1]);
	return point;
}

function copyAndSplit() {
	//duplicate image for channel splitting
	run("Duplicate...", "title=draw");
	run("Duplicate...", "title=working");
	selectWindow("working");
	run("RGB Split");
}

function makeROIFromPoint(point, imageID){

	// roiManager("reset");
	selectImage(imageID);
	run("Duplicate...", "title=temp"); //a copy of the primary image
	selectImage("temp");
	setThreshold(nucleusThresholdLevel, 255);  // Set the threshold
	
	doWand(point[0], point[1]);
	roiManager("Add"); // add line to ROI

	run("Set Measurements...", "perimeter");
	run("Measure");
	
	if(nResults > 0){
		perimeter = getResult('Perim.');
		addToLog("NP", perimeter);
	}
	
	resetThreshold();
	
	// find the coordinates of the ROI
	// run("Interpolate", "interval=1 smooth"); // Edit>Selection>Interpolate
	getSelectionCoordinates(xpoints, ypoints); 
	
	close("temp");
	newROI = createROI(xpoints, ypoints); 
	
	return newROI;
}

function drawSpermTip(roi){

	x = ROI_to_x(roi);
	y = ROI_to_y(roi);
	selectWindow("draw");
	setColor("#7D26CD");
	drawRect(x[0]-1, y[0]-1, 3, 3);
}

function writeDualROI(roi1, roi2, file){
	x1 = ROI_to_x(roi1);
	y1 = ROI_to_y(roi1);

	x2 = ROI_to_x(roi2);
	y2 = ROI_to_y(roi2);
	
	for(i=0;i<x1.length;i++){
		print(file, x1[i]+"\t"+y1[i]+"\t"+x2[i]+"\t"+y2[i]);
	}
}

*/
// -------------------------------------------------
// MACROS
// -------------------------------------------------
macro "Sperm Morph Tool - C0a0L18f8L818f"
{
	requires("1.47");
	saveSettings();
	main();
	restoreSettings();
}